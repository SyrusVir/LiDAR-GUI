import zmq
from zmq.utils.monitor import recv_monitor_message
import sys
from os.path import dirname
sys.path.append(dirname(dirname(__file__)))
from PyQt5 import QtCore as qtc, QtWidgets as qtw
import traceback
import time


class ZmqMonitor(qtc.QObject):
    ##ZMQ Signals associated with a ZMQ event ############################

    #ZMQ_EVENT_CONNECTED
    #The socket has successfully connected to a remote peer. 
    # The event value is the file descriptor (FD) of the underlying 
    # network socket. 
    # Warning: there is no guarantee that the FD is still valid by 
    # the time your code receives this event.
    sig_connected = qtc.pyqtSignal(object)
    
    #ZMQ_EVENT_CONNECT_DELAYED
    #A connect request on the socket is pending. The event value is unspecified.
    sig_connect_delayed = qtc.pyqtSignal(object)

    #ZMQ_EVENT_CONNECT_RETRIED
    #A connect request failed, and is now being retried. The event value is the reconnect interval in milliseconds. Note that the reconnect interval is recalculated at each retry.
    sig_connect_retired = qtc.pyqtSignal(object)

    #ZMQ_EVENT_LISTENING
    #The socket was successfully bound to a network interface. The event value is the FD of the underlying network socket. Warning: there is no guarantee that the FD is still valid by the time your code receives this event.
    sig_listening = qtc.pyqtSignal(object)
    
    #ZMQ_EVENT_BIND_FAILED
    #The socket could not bind to a given interface. The event value is the errno generated by the system bind call.
    sig_bind_failed = qtc.pyqtSignal(object)
    
    #ZMQ_EVENT_ACCEPTED
    #The socket has accepted a connection from a remote peer. The event value is the FD of the underlying network socket. Warning: there is no guarantee that the FD is still valid by the time your code receives this event.
    sig_accepted = qtc.pyqtSignal(object)
    
    #ZMQ_EVENT_ACCEPT_FAILED
    #The socket has rejected a connection from a remote peer. The event value is the errno generated by the accept call.
    sig_accept_failed = qtc.pyqtSignal(object)
    
    #ZMQ_EVENT_CLOSED
    #The socket was closed. The event value is the FD of the (now closed) network socket.
    sig_closed = qtc.pyqtSignal(object)
    
    #ZMQ_EVENT_CLOSE_FAILED
    #The socket close failed. The event value is the errno returned by the system call. 
    # Note that this event occurs only on IPC transports.
    sig_close_failed = qtc.pyqtSignal(object)
    
    #ZMQ_EVENT_DISCONNECTED
    #The socket was disconnected unexpectedly. 
    # The event value is the FD of the underlying network socket. 
    # Warning: this socket will be closed.
    sig_disconnected = qtc.pyqtSignal(object)
    
    #ZMQ_EVENT_MONITOR_STOPPED
    #Monitoring on this socket ended.
    sig_monitor_stopped = qtc.pyqtSignal(object)

    #ZMQ_EVENT_HANDSHAKE_FAILED_NO_DETAIL
    #Unspecified error during handshake. The event value is an errno.
    sig_handshake_failed = qtc.pyqtSignal(object)

    #ZMQ_EVENT_HANDSHAKE_SUCCEEDED
    #The ZMTP security mechanism handshake succeeded. The event value is unspecified.
    sig_handhake_succeeded  = qtc.pyqtSignal(object)
    
    #ZMQ_EVENT_HANDSHAKE_FAILED_PROTOCOL
    #The ZMTP security mechanism handshake failed due to some mechanism protocol error, either 
    # between the ZMTP mechanism peers, or between the mechanism server and the ZAP handler. 
    # This indicates a configuration or implementation error in either peer resp. the ZAP handler. 
    # The event value is one of the ZMQ_PROTOCOL_ERROR_* values: 
    #   ZMQ_PROTOCOL_ERROR_ZMTP_UNSPECIFIED 
    #   ZMQ_PROTOCOL_ERROR_ZMTP_UNEXPECTED_COMMAND 
    #   ZMQ_PROTOCOL_ERROR_ZMTP_INVALID_SEQUENCE 
    #   ZMQ_PROTOCOL_ERROR_ZMTP_KEY_EXCHANGE
    #   ZMQ_PROTOCOL_ERROR_ZMTP_MALFORMED_COMMAND_UNSPECIFIED 
    #   ZMQ_PROTOCOL_ERROR_ZMTP_MALFORMED_COMMAND_MESSAGE   
    #   ZMQ_PROTOCOL_ERROR_ZMTP_MALFORMED_COMMAND_HELLO 
    #   ZMQ_PROTOCOL_ERROR_ZMTP_MALFORMED_COMMAND_INITIATE 
    #   ZMQ_PROTOCOL_ERROR_ZMTP_MALFORMED_COMMAND_ERROR 
    #   ZMQ_PROTOCOL_ERROR_ZMTP_MALFORMED_COMMAND_READY     
    #   ZMQ_PROTOCOL_ERROR_ZMTP_MALFORMED_COMMAND_WELCOME 
    #   ZMQ_PROTOCOL_ERROR_ZMTP_INVALID_METADATA    
    #   ZMQ_PROTOCOL_ERROR_ZMTP_CRYPTOGRAPHIC 
    #   ZMQ_PROTOCOL_ERROR_ZMTP_MECHANISM_MISMATCH 
    #   ZMQ_PROTOCOL_ERROR_ZAP_UNSPECIFIED 
    #   ZMQ_PROTOCOL_ERROR_ZAP_MALFORMED_REPLY 
    #   ZMQ_PROTOCOL_ERROR_ZAP_BAD_REQUEST_ID 
    #   ZMQ_PROTOCOL_ERROR_ZAP_BAD_VERSION 
    #   ZMQ_PROTOCOL_ERROR_ZAP_INVALID_STATUS_CODE
    #   ZMQ_PROTOCOL_ERROR_ZAP_INVALID_METADATA
    sig_handshake_failed_proto = qtc.pyqtSignal(object)
    

    #ZMQ_EVENT_HANDSHAKE_FAILED_AUTH
    #The ZMTP security mechanism handshake failed due to an authentication failure. 
    # The event value is the status code returned by the ZAP handler (i.e. 300, 400 or 500).
    sig_handshake_failed_auth = qtc.pyqtSignal(object)

    ###########################################################################################
    
    ##Custom signals not associated with ZMQ############################################
    #not associated with ZMQ
    sig_error_occurred = qtc.pyqtSignal(dict)
    
   

    #####################################################################################
    
    def __init__(self, socket: zmq.Socket, *args, **kwargs):
        super().__init__(*args, **kwargs)
        
        #create dictionary of ZMQ events, event id's, and descriptions
        self.EVENT_MAP = self.generateEventDict() 

        #dictionary associating a ZMQ socket event id with a PyQt5 signal
        self.zmq_signal_dict = {
            1: self.sig_connected,
            2: self.sig_connect_delayed,
            4: self.sig_connect_retired,
            8: self.sig_listening,
            16: self.sig_bind_failed,
            32: self.sig_accepted,
            64: self.sig_accept_failed,
            128: self.sig_closed,
            256: self.sig_close_failed,
            512: self.sig_disconnected,
            1024: self.sig_monitor_stopped,
            2048: self.sig_handshake_failed,
            8192: self.sig_handshake_failed_proto,
            4096: self.sig_handhake_succeeded,
            16384: self.sig_handshake_failed_auth
        }

        self.socket = socket    #save ZMQ socket object
        self.monitor_socket = socket.get_monitor_socket()   #get monitoring socket PAIR 

        #signal pass throughs; these events will emit the error signal, passing event data
        self.sig_bind_failed.connect(self.sig_error_occurred.emit)
        self.sig_accept_failed.connect(self.sig_error_occurred.emit)
        self.sig_handshake_failed.connect(self.sig_error_occurred.emit)
        self.sig_handshake_failed_auth.connect(self.sig_error_occurred.emit)
        self.sig_handshake_failed_proto.connect(self.sig_error_occurred.emit)

         
    def generateEventDict(self) -> dict:
        '''
        Loop through all attributes of the zmq package that begin 
        with 'EVENT_', saving it's name and value in a dictionary
        '''
        EVENT_MAP = {}
        for name in dir(zmq):
            if name.startswith('EVENT_'):
                value = getattr(zmq,name)
                EVENT_MAP[value] = name
        
        return EVENT_MAP

    def startWork(self):
        #self.monitor_socket_notifier = qtc.QSocketNotifier(zmq.getsockopt(zmq.FD), qtc.QSocketNotifier.Read, self)
        #self.monitor_socket_notifier.activated.connect(self.monitorSocket)
        pass

    @qtc.pyqtSlot()
    def monitorSocket(self):
        '''
        Main monitoring function. While loop that receives message
        from the monitoring PAIR socket as they arrive. Emit provided signals
        according to received events
        '''
        print("Hello from thread {}".format(qtc.QThread.currentThreadId()))
        while True: 
            evt = recv_monitor_message(self.monitor_socket) #block until message available
            evt.update({'description': self.EVENT_MAP[evt['event']]}) #add description to received tuple
            print("Event: {}".format(evt))
            self.zmq_signal_dict[evt['event']].emit(evt)    #use 'event' key to get proper signal; emit signal, passing event data
            if evt['event'] == zmq.EVENT_MONITOR_STOPPED:
                break
        
        self.monitor_socket.close()

if __name__ == "__main__":
    class MainWindow(qtw.QApplication):
        sig_start_monitor = qtc.pyqtSignal()

        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            self.context = zmq.Context()
            self.publisher = self.context.socket(zmq.PUB)
            self.subscriber = self.context.socket(zmq.SUB)
            self.subscriber_notifier = qtc.QSocketNotifier(self.subscriber.getsockopt(zmq.FD), qtc.QSocketNotifier.Read)
            
            self.monitor = ZmqMonitor(self.subscriber)
            self.monitor_thread = qtc.QThread(self)
            self.monitor.moveToThread(self.monitor_thread)
            
            self.subscriber_notifier.activated.connect(self.socketActivity)
            self.monitor.sig_connected.connect(lambda x: print(f"CONNECTED SIGNAL EMITTED {x}"))
            self.monitor.sig_connect_delayed.connect(lambda x: print(f"CONNECT DELAY SIGNAL EMITTED {x}"))
            self.monitor.sig_handhake_succeeded.connect(lambda x: print(f"HANDSHAKE SUCCESS SIGNAL EMITTED {x}"))
            self.monitor.sig_monitor_stopped.connect(lambda x: print(f"MONITOR STOP SIGNAL EMITTED {x}"))
            self.monitor.sig_error_occurred.connect(lambda x: print(f"ERROR SIGNAL EMITTED: {x}"))
            self.sig_start_monitor.connect(self.monitor.monitorSocket)
            self.monitor_thread.finished.connect(self.monitor.deleteLater)
            self.monitor_thread.started.connect(self.monitor.monitorSocket)
            
            print("starting in {}".format(qtc.QThread.currentThreadId()))
            self.monitor_thread.start()

            #self.monitor.monitor_signals.zmq_signal_dict[1].emit({})
            #self.monitor.monitor_signals.sig_connected.emit({})
            self.subscriber.connect("tcp://localhost:49217")
            self.subscriber.setsockopt_string(zmq.SUBSCRIBE, '')
            #self.publisher.bind('tcp://*:49217')
            
            qtc.QTimer.singleShot(10000, self.quitThread)
            print("end")
            
            
        def socketActivity(self):
            self.subscriber_notifier.setEnabled(False)

            if (self.subscriber.getsockopt(zmq.EVENTS) & zmq.POLLIN):
                while (self.subscriber.getsockopt(zmq.EVENTS) & zmq.POLLIN):
                    print(self.subscriber.recv_string())
                
            self.subscriber_notifier.setEnabled(True)

        def quitThread(self):            
            print("about to close")
            self.subscriber_notifier.setEnabled(False)
            self.subscriber.close()
            #self.subscriber.disconnect("tcp://localhost:49217")
            #publisher.close()
            print("about to quit thread")
            self.monitor_thread.quit()
            print("about to wait for thread")
            self.monitor_thread.wait()
            print("about to destroy context")
            self.context.destroy()
            sys.exit()
    
    app = MainWindow(sys.argv)
    sys.exit(app.exec_())